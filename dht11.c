#include "dht11.h"

#define JUDGE  30                //用于判断通信的0和1，与单片机速度和晶振频率有关



void delay30us()                //@11.0592MHz
{
        unsigned char i;

        i = 80;
        while (--i);
}



void delay20ms()                //@11.0592MHz
{
        unsigned char i, j, k;

        i = 1;
        j = 216;
        k = 35;
        do
        {
                do
                {
                        while (--k);
                } while (--j);
        } while (--i);
}


/*********************************************************************************************
函数名：DHT11读数据函数
调  用：? = GetData();
参  数：无
返回值：失败->-1,-2,-3,-4;成功->0
结  果：读DHT11数据并保存到数组dat_r[]
备  注：
**********************************************************************************************/
char GetData (u8 *dat)
{
        u8 i,j;                                //for循环变量
        u8 t;                                //超时判断
        u8 dat8=0;                        //一次读取的8位数据，需要读5次

        DATA_IO = 0;                                //主机发起始信号
        delay20ms();                        //主机拉低总线至少18ms
        DATA_IO = 1;                                //主机拉高总线20~40us
        delay30us();

        t = 80;                                        //设置超时等待时间
        while(DATA_IO && t--);                //等待DHT11拉低总线
        if(t == 0)                                //超时
        {
                DATA_IO = 1;
                return 1;                        //通信错误退出，返回错误信号：-1
        }

        //等80us响应信号
        t = 250;                                //设置超时等待时间
        while(!DATA_IO && t--);        //等待DHT11拉高总线
        if(t == 0)                                //超时
        {
                DATA_IO = 1;
                return 2;                        //通信错误退出，返回错误信号：-2
        }

        //等80us响应信号
        t = 250;                                //设置超时等待时间
        while(DATA_IO && t--);                //等待DHT11拉低总线
        if(t == 0)                                //超时
        {
                DATA_IO = 1;
                return 3;                        //通信错误退出，返回错误信号：-3
        }

        for(j=0; j<5; j++)                //5次读取
        {
                for(i=0; i<8; i++)                        //1次8个位
                {
                        //等待50us开始时隙
                        t = 150;                                //设置超时等待时间
                        while(!DATA_IO && t--);        //等待DHT11拉高总线
                        if(t == 0)                                //超时
                        {
                                DATA_IO = 1;
                                return 4;                        //通信错误退出，返回错误信号：-4
                        }
                        t = 0;                                        //记录时间清零
                        while(DATA_IO && ++t);                //等待并记录高电平持续时间
                        dat8 <<= 1;
                        if(t > JUDGE)                        //高电平持续时间较长(70us)
                                dat8 += 1;                        //传输值为1
                        //else dat8 += 0;
                }
                dat[j] = dat8;
        }

        delay30us();                //等待DHT11拉低50us
        delay30us();
        DATA_IO = 1;                        //结束，拉高总线
        return 0;                        //返回成功信号
}

/*********************************************************************************************
函数名：数据校验函数
调  用：? = Check();
参  数：无
返回值：成功->0;失败->1;
结  果：数据校验
备  注：数据传送正确时校验和数据等于“8bit湿度整数数据+8bit湿度小数数据+8bi温度整数数据+8bit温度小数数据”所得结果的末8位。
**********************************************************************************************/
char Check (u8 *dat)
{
        u8 i;                        //for循环变量
        u16 chk=0;                        //校验和
        for(i=0; i<4; i++)
                chk += dat[i];                //累加
        if((u8)chk != dat[4])        //比对
                return 1;                                //返回错误信号：1
        else
                return 0;                                //返回正确信号：0
}

