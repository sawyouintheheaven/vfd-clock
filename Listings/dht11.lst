C51 COMPILER V9.56.0.0   DHT11                                                             07/24/2019 14:12:51 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE DHT11
OBJECT MODULE PLACED IN .\Objects\dht11.obj
COMPILER INVOKED BY: D:\keil\C51\BIN\C51.EXE dht11.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\
                    -dht11.lst) TABS(2) OBJECT(.\Objects\dht11.obj)

line level    source

   1          #include "dht11.h"
   2          
   3          #define JUDGE  30                //用于判断通信的0和1，与单片机速度和晶振频率有关
   4          
   5          
   6          
   7          void delay30us()                //@11.0592MHz
   8          {
   9   1              unsigned char i;
  10   1      
  11   1              i = 80;
  12   1              while (--i);
  13   1      }
  14          
  15          
  16          
  17          void delay20ms()                //@11.0592MHz
  18          {
  19   1              unsigned char i, j, k;
  20   1      
  21   1              i = 1;
  22   1              j = 216;
  23   1              k = 35;
  24   1              do
  25   1              {
  26   2                      do
  27   2                      {
  28   3                              while (--k);
  29   3                      } while (--j);
  30   2              } while (--i);
  31   1      }
  32          
  33          
  34          /*********************************************************************************************
  35          函数名：DHT11读数据函数
  36          调  用：? = GetData();
  37          参  数：无
  38          返回值：失败->-1,-2,-3,-4;成功->0
  39          结  果：读DHT11数据并保存到数组dat_r[]
  40          备  注：
  41          **********************************************************************************************/
  42          char GetData (u8 *dat)
  43          {
  44   1              u8 i,j;                                //for循环变量
  45   1              u8 t;                                //超时判断
  46   1              u8 dat8=0;                        //一次读取的8位数据，需要读5次
  47   1      
  48   1              DATA_IO = 0;                                //主机发起始信号
  49   1              delay20ms();                        //主机拉低总线至少18ms
  50   1              DATA_IO = 1;                                //主机拉高总线20~40us
  51   1              delay30us();
  52   1      
  53   1              t = 80;                                        //设置超时等待时间
  54   1              while(DATA_IO && t--);                //等待DHT11拉低总线
C51 COMPILER V9.56.0.0   DHT11                                                             07/24/2019 14:12:51 PAGE 2   

  55   1              if(t == 0)                                //超时
  56   1              {
  57   2                      DATA_IO = 1;
  58   2                      return 1;                        //通信错误退出，返回错误信号：-1
  59   2              }
  60   1      
  61   1              //等80us响应信号
  62   1              t = 250;                                //设置超时等待时间
  63   1              while(!DATA_IO && t--);        //等待DHT11拉高总线
  64   1              if(t == 0)                                //超时
  65   1              {
  66   2                      DATA_IO = 1;
  67   2                      return 2;                        //通信错误退出，返回错误信号：-2
  68   2              }
  69   1      
  70   1              //等80us响应信号
  71   1              t = 250;                                //设置超时等待时间
  72   1              while(DATA_IO && t--);                //等待DHT11拉低总线
  73   1              if(t == 0)                                //超时
  74   1              {
  75   2                      DATA_IO = 1;
  76   2                      return 3;                        //通信错误退出，返回错误信号：-3
  77   2              }
  78   1      
  79   1              for(j=0; j<5; j++)                //5次读取
  80   1              {
  81   2                      for(i=0; i<8; i++)                        //1次8个位
  82   2                      {
  83   3                              //等待50us开始时隙
  84   3                              t = 150;                                //设置超时等待时间
  85   3                              while(!DATA_IO && t--);        //等待DHT11拉高总线
  86   3                              if(t == 0)                                //超时
  87   3                              {
  88   4                                      DATA_IO = 1;
  89   4                                      return 4;                        //通信错误退出，返回错误信号：-4
  90   4                              }
  91   3                              t = 0;                                        //记录时间清零
  92   3                              while(DATA_IO && ++t);                //等待并记录高电平持续时间
  93   3                              dat8 <<= 1;
  94   3                              if(t > JUDGE)                        //高电平持续时间较长(70us)
  95   3                                      dat8 += 1;                        //传输值为1
  96   3                              //else dat8 += 0;
  97   3                      }
  98   2                      dat[j] = dat8;
  99   2              }
 100   1      
 101   1              delay30us();                //等待DHT11拉低50us
 102   1              delay30us();
 103   1              DATA_IO = 1;                        //结束，拉高总线
 104   1              return 0;                        //返回成功信号
 105   1      }
 106          
 107          /*********************************************************************************************
 108          函数名：数据校验函数
 109          调  用：? = Check();
 110          参  数：无
 111          返回值：成功->0;失败->1;
 112          结  果：数据校验
 113          备  注：数据传送正确时校验和数据等于“8bit湿度整数数据+8bit湿度小数数据+8bi温度整数数据+8bit温度小数数据”
             -所得结果的末8位。
 114          **********************************************************************************************/
 115          char Check (u8 *dat)
C51 COMPILER V9.56.0.0   DHT11                                                             07/24/2019 14:12:51 PAGE 3   

 116          {
 117   1              u8 i;                        //for循环变量
 118   1              u16 chk=0;                        //校验和
 119   1              for(i=0; i<4; i++)
 120   1                      chk += dat[i];                //累加
 121   1              if((u8)chk != dat[4])        //比对
 122   1                      return 1;                                //返回错误信号：1
 123   1              else
 124   1                      return 0;                                //返回正确信号：0
 125   1      }
 126          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    281    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
